<div align="center">

# 🧠 [3270. Find the Key of the Numbers](https://leetcode.com/problems/find-the-key-of-the-numbers/)

[![LeetCode](https://img.shields.io/badge/LeetCode-Problem%203270-FFA116?style=for-the-badge&logo=leetcode&logoColor=white)](https://leetcode.com/problems/find-the-key-of-the-numbers/)

</div>

---

## 📋 Problem Overview

| Property            | Value                                                                          |
| ------------------- | ------------------------------------------------------------------------------ |
| **Difficulty**      | 🟢 **Easy**                                                                    |
| **Acceptance Rate** | `76.1%`                                                                        |
| **Problem Link**    | [Open in LeetCode](https://leetcode.com/problems/find-the-key-of-the-numbers/) |
| **Tags**            | ![Math](https://img.shields.io/badge/-Math-blue?style=flat-square)             |

## Description

<!-- description:start -->

<p>You are given three <strong>positive</strong> integers <code>num1</code>, <code>num2</code>, and <code>num3</code>.</p>

<p>The <code>key</code> of <code>num1</code>, <code>num2</code>, and <code>num3</code> is defined as a four-digit number such that:</p>

<ul>
  <li>If any number has <strong>less than</strong> four digits, it is padded with <strong>leading zeros</strong>.</li>
  <li>The <code>i<sup>th</sup></code> digit (<code>1 &lt;= i &lt;= 4</code>) of the <code>key</code> is generated by taking the <strong>smallest</strong> digit among the <code>i<sup>th</sup></code> digits of <code>num1</code>, <code>num2</code>, and <code>num3</code>.</li>
</ul>

<p>Return the <code>key</code> of the three numbers <strong>without</strong> leading zeros (<em>if any</em>).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> num1 = 1, num2 = 10, num3 = 1000
<strong>Output:</strong> 0
<strong>Explanation:</strong> 
On padding, <code>num1</code> becomes <code>"0001"</code>, <code>num2</code> becomes <code>"0010"</code>, and <code>num3</code> remains <code>"1000"</code>.
- 1st digit of key = min(0, 0, 1) = 0
- 2nd digit of key = min(0, 0, 0) = 0
- 3rd digit of key = min(0, 1, 0) = 0
- 4th digit of key = min(1, 0, 0) = 0
Thus, key = "0000" → 0
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> num1 = 987, num2 = 879, num3 = 798
<strong>Output:</strong> 777
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> num1 = 1, num2 = 2, num3 = 3
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
  <li><code>1 &lt;= num1, num2, num3 &lt;= 9999</code></li>
</ul>

<!-- description:end -->

## ⏰ Progress Tracking

| Status           | Date         | Notes                                    |
| ---------------- | ------------ | ---------------------------------------- |
| 🎯 **Attempted** | `15-09-2025` | First attempt, understanding the problem |
| ✅ **Solved**    | `15-09-2025` | Successfully implemented solution        |
| 🔄 **Review 1**  | `DD-MM-YYYY` | First review, optimization               |
| 🔄 **Review 2**  | `DD-MM-YYYY` | Second review, different approaches      |
| 🔄 **Review 3**  | `DD-MM-YYYY` | Final review, mastery                    |

## 🔗 Related Problems

| Problem                                                         | Difficulty    | Relationship  |
| --------------------------------------------------------------- | ------------- | ------------- |
| [Largest Number](https://leetcode.com/problems/largest-number/) | 🟡 **Medium** | Similar logic |

---

## 💡 Solutions

### 🥉 Approach 1: Brute Force (String Padding)

#### 📝 Intuition

> - Convert each number to a 4-digit string (with leading zeros).
> - Compare each digit position (from 1 to 4).
> - Take the minimum digit across the three numbers at that position.
> - Build the key string.
> - Convert back to integer (to remove leading zeros).
> - This approach is very direct but involves string manipulation.

#### 🔍 Algorithm

```pseudo
function bruteForce(num1, num2, num3):
    s1 = pad num1 to 4 digits
    s2 = pad num2 to 4 digits
    s3 = pad num3 to 4 digits
    key = ""
    for i in 0..3:
        d = min(s1[i], s2[i], s3[i])
        append d to key
    return integer(key)
```

#### 💻 Implementation

```cpp
// Brute force using string padding

class Solution {
public:
    int generateKey(int num1, int num2, int num3) {
        // Convert to 4-digit strings with leading zeros
        string s1 = string(4 - to_string(num1).size(), '0') + to_string(num1);
        string s2 = string(4 - to_string(num2).size(), '0') + to_string(num2);
        string s3 = string(4 - to_string(num3).size(), '0') + to_string(num3);

        string key = "";
        // Take min digit for each of 4 positions
        for (int i = 0; i < 4; i++) {
            char d = min({s1[i], s2[i], s3[i]});
            key.push_back(d);
        }

        // Convert string to integer (removes leading zeros automatically)
        return stoi(key);
    }
};
```

### 🥈 Approach 2: Optimized Solution (Digit Array)

#### 📝 Intuition

> - Instead of strings, work with arrays of digits.
> - Extract digits of each number and pad with zeros at the front until length = 4.
> - Compare column by column (MSD → LSD).
> - Build result number.
> - This avoids string concatenation, working only with integers.

#### 🔍 Algorithm

```pseudo
function optimized(num1, num2, num3):
    d1 = array of 4 digits of num1 (with padding)
    d2 = array of 4 digits of num2
    d3 = array of 4 digits of num3
    result = 0
    for i in 0..3:
        result = result * 10 + min(d1[i], d2[i], d3[i])
    return result
```

#### 💻 Implementation

```cpp
// Optimized approach using digit arrays

class Solution {
public:
    // Helper: convert integer to a 4-digit array
    vector<int> toDigits(int num) {
        vector<int> digits(4, 0);
        for (int i = 3; i >= 0 && num > 0; i--) {
            digits[i] = num % 10;
            num /= 10;
        }
        return digits;
    }

    int generateKey(int num1, int num2, int num3) {
        vector<int> d1 = toDigits(num1);
        vector<int> d2 = toDigits(num2);
        vector<int> d3 = toDigits(num3);

        int result = 0;
        for (int i = 0; i < 4; i++) {
            int digit = min({d1[i], d2[i], d3[i]});
            result = result * 10 + digit;
        }
        return result;
    }
};
```

### 🥇 Approach 3: Optimal Solution ⭐ (Compact, No Extra Storage)

#### 📝 Intuition

> - Process digits directly from most significant digit (thousands → hundreds → tens → ones).
> - For each place value, extract the digit of num1, num2, num3 using division/modulus.
> - Take the minimum.
> - Construct the result incrementally.
> - This avoids strings and arrays → O(1) space, O(1) time.

#### 🔍 Algorithm

```pseudo
function optimal(num1, num2, num3):
    result = 0
    place = [1000, 100, 10, 1]
    for each p in place:
        d1 = (num1 / p) % 10
        d2 = (num2 / p) % 10
        d3 = (num3 / p) % 10
        result = result * 10 + min(d1, d2, d3)
    return result
```

#### 💻 Implementation

```cpp
// Most optimal: direct digit extraction without strings/arrays

class Solution {
public:
    int generateKey(int num1, int num2, int num3) {
        int result = 0;
        int places[4] = {1000, 100, 10, 1}; // place values

        for (int p : places) {
            int d1 = (num1 / p) % 10;
            int d2 = (num2 / p) % 10;
            int d3 = (num3 / p) % 10;

            int digit = min({d1, d2, d3});
            result = result * 10 + digit;
        }
        return result;
    }
};
```

## 📊 Comparison of Approaches

| Approach       | Time Complexity | Space Complexity | Pros                                 | Cons                            |
| -------------- | --------------- | ---------------- | ------------------------------------ | ------------------------------- |
| 🥉 Brute Force | O(1)            | O(1)             | Very intuitive with strings          | Uses string manipulation        |
| 🥈 Optimized   | O(1)            | O(1)             | Cleaner math-only approach           | Slightly more verbose (arrays)  |
| 🥇 Optimal ⭐  | O(1)            | O(1)             | Most elegant, compact, direct digits | Requires careful place handling |

---

<div align="center">

**🎯 Problem 3270 Completed!**

_Happy Coding! 🚀_

</div>
