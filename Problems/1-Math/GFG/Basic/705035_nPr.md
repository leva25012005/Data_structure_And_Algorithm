<div align="center">

# üß† [nPr](https://www.geeksforgeeks.org/problems/npr4253/1)

[![GeeksforGeeks](https://img.shields.io/badge/GeeksforGeeks-Problem-0F9D58?style=for-the-badge&logo=geeksforgeeks&logoColor=white)](https://www.geeksforgeeks.org/problems/npr4253/1)

</div>

---

## üìã Problem Overview

| Property         | Value                                                                                                                                                                                                                                              |
| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Problem ID**   | `705035`                                                                                                                                                                                                                                           |
| **Difficulty**   | ‚ö™ **Basic**                                                                                                                                                                                                                                       |
| **Accuracy**     | `35.25%`                                                                                                                                                                                                                                           |
| **Problem Link** | [Open in GeeksforGeeks](https://www.geeksforgeeks.org/problems/npr4253/1)                                                                                                                                                                          |
| **Topic Tags**   | ![Mathematical](https://img.shields.io/badge/-Mathematical-blue?style=flat-square) ![permutation](https://img.shields.io/badge/-permutation-blue?style=flat-square) ![Algorithms](https://img.shields.io/badge/-Algorithms-blue?style=flat-square) |

## Description

<!-- description:start -->

<p>Write a program to calculate <code>nPr</code>. <code>nPr</code> represents the number of permutations of <code>n</code> items taken <code>r</code> at a time. The value of <code>nPr</code> is given by:</p>

<p><code>nPr = n! / (n - r)!</code></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 5, r = 2
<strong>Output:</strong> 20
<strong>Explanation:</strong> 5! / (5-2)! = 5! / 3! = 120 / 6 = 20
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 6, r = 3
<strong>Output:</strong> 120
<strong>Explanation:</strong> 6! / (6-3)! = 6! / 3! = 720 / 6 = 120
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
  <li><code>1 &lt;= n, r &lt;= 20</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Expected Time Complexity:</strong> O(n)<br>
<strong>Expected Auxiliary Space:</strong> O(1)</p>
<!-- description:end -->

## ‚è∞ Progress Tracking

| Status           | Date         | Notes                                    |
| ---------------- | ------------ | ---------------------------------------- |
| üéØ **Attempted** | `18-09-2025` | First attempt, understanding the problem |
| ‚úÖ **Solved**    | `18-09-2025` | Successfully implemented solution        |
| üîÑ **Review 1**  | `DD-MM-YYYY` | First review, optimization               |
| üîÑ **Review 2**  | `DD-MM-YYYY` | Second review, different approaches      |
| üîÑ **Review 3**  | `DD-MM-YYYY` | Final review, mastery                    |

## üìö Related Articles

1. [GeeksforGeeks Article 1](https://www.geeksforgeeks.org/program-to-calculate-the-value-of-npr/)

---

## üí° Solutions

### ü•â Approach 1: Brute Force (Factorial Function)

#### üìù Intuition

> - Directly compute n! and (n-r)!, then divide.
> - Use a simple factorial function.
> - Since n, r ‚â§ 20, no overflow issues with long long

#### üîç Algorithm

```pseudo
function bruteForce(n, r):
    fact(n) = 1 * 2 * ... * n
    return fact(n) / fact(n-r)
```

#### üíª Implementation

```cpp
// Brute force factorial-based solution

class Solution {
public:
    long long factorial(int x) {
        long long res = 1;
        for (int i = 2; i <= x; i++) {
            res *= i;
        }
        return res;
    }

    long long nPr(int n, int r) {
        // Formula: nPr = n! / (n-r)!
        return factorial(n) / factorial(n - r);
    }
};
```

### ü•à Approach 2: Optimized Solution (Partial Factorial)

#### üìù Intuition

> - Instead of computing full factorials, observe that:
> - nPr = n! / (n-r)! = n _ (n-1) _ (n-2) _ ... _ (n-r+1)
> - Only multiply r terms, no need to compute two factorials.
> - More efficient and avoids unnecessary big numbers.

#### üîç Algorithm

```pseudo
function optimized(n, r):
    result = 1
    for i = 0 to r-1:
        result *= (n - i)
    return result
```

#### üíª Implementation

```cpp
// Optimized approach: multiply only r terms

class Solution {
public:
    long long nPr(int n, int r) {
        long long res = 1;
        for (int i = 0; i < r; i++) {
            res *= (n - i); // Multiply n * (n-1) * ... * (n-r+1)
        }
        return res;
    }
};
```

### ü•á Approach 3: Optimal Solution ‚≠ê (Recursive with Memoization)

#### üìù Intuition

> - Use recursive definition:
> - nPr = n \* (n-1)P(r-1)
> - This relation can be memoized for efficiency.
> - Not necessary for small constraints (n ‚â§ 20), but shows elegant DP/recursive solution.

#### üîç Algorithm

```pseudo
function optimal(n, r):
    if r == 0: return 1
    if r == 1: return n
    return n * (n-1)P(r-1)
```

#### üíª Implementation

```cpp
// Optimal recursive solution with memoization

class Solution {
public:
    long long dp[25][25]; // memo table (n,r) since n,r <= 20

    Solution() {
        memset(dp, -1, sizeof(dp));
    }

    long long nPrHelper(int n, int r) {
        if (r == 0) return 1;
        if (dp[n][r] != -1) return dp[n][r];
        return dp[n][r] = n * nPrHelper(n - 1, r - 1);
    }

    long long nPr(int n, int r) {
        return nPrHelper(n, r);
    }
};
```

## üìä Comparison of Approaches

| Approach       | Time Complexity | Space Complexity  | Pros                                    | Cons                                      |
| -------------- | --------------- | ----------------- | --------------------------------------- | ----------------------------------------- |
| ü•â Brute Force | O(n)            | O(1)              | Very simple, easy to understand         | Computes more factorial terms than needed |
| ü•à Optimized   | O(r)            | O(1)              | Efficient, only multiplies needed terms | None (best for this constraint)           |
| ü•á Optimal ‚≠ê  | O(r)            | O(n¬∑r) (DP table) | Elegant recursive/DP style              | Overkill for small n, extra memory        |

---

<div align="center">

**üéØ Problem 705035 Completed!**

_Happy Coding! üöÄ_

</div>
